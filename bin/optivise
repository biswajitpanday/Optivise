#!/usr/bin/env node
import { spawn } from 'child_process';
import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const PACKAGE_ROOT = path.join(__dirname, '..');

function printUsage() {
  const packagePath = path.join(PACKAGE_ROOT, 'package.json');
  let version = '4.0.0';
  try {
    const packageData = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
    version = packageData.version;
  } catch (error) {
    console.error('Warning: Could not read package.json version, using default');
  }

  console.log(`
Optivise v${version} - Intelligent MCP Tool for Optimizely Context Analysis

USAGE:
  optivise [COMMAND] [OPTIONS]

COMMANDS:
  mcp           Start MCP server for IDE integration
  start         Start MCP server (alias for mcp)
  server        Start HTTP server for browser testing (port 3000)
  dev           Start in development mode with hot reload
  test          Test MCP connectivity and configuration
  detect        Detect Optimizely products in current directory
  setup         Generate IDE configuration
  version       Show version information

OPTIONS:
  --debug       Enable debug mode with verbose logging
  --help        Show this help message

EXAMPLES:
  optivise mcp              # Start MCP server for IDE integration
  optivise server           # Start HTTP server for browser testing
  optivise test             # Test MCP connectivity and configuration
  optivise detect           # Detect Optimizely products in current project
  optivise setup            # Generate IDE configuration
  optivise --debug mcp      # Start MCP server with debug logs

üöÄ NEW in v3.0.0: Simplified Architecture
   ‚Ä¢ Single context analyzer tool
   ‚Ä¢ Intelligent product detection (11+ Optimizely products)
   ‚Ä¢ Modern TypeScript with native compilation
   ‚Ä¢ Enhanced relevance scoring and context curation

For more information, visit: https://github.com/biswajitpanday/OptiDevDoc
  `);
}

function printVersion() {
  const packagePath = path.join(PACKAGE_ROOT, 'package.json');
  try {
    const packageData = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
    console.log(`Optivise v${packageData.version}`);
    console.log(`üéØ Intelligent MCP tool for Optimizely context analysis`);
    console.log(`üìö Products: Commerce, CMS, Experimentation, DXP, and more`);
    console.log(`üîß Features: Context analysis, product detection, relevance scoring`);
    console.log(`üéØ Focus: AI-assisted development with curated Optimizely context`);
  } catch (error) {
    console.log('Optivise v4.0.0');
  }
}

function detectOptimizelyProduct(options) {
  console.log('üîç Detecting Optimizely Products...');
  
  const projectPath = process.cwd();
  console.log(`üìÅ Analyzing project: ${projectPath}\n`);
  
  const detectedFeatures = [];
  
  try {
    // Check for Commerce indicators
    if (fs.existsSync('Extensions') || fs.existsSync('InsiteCommerce.Web')) {
      detectedFeatures.push('üõí Configured Commerce - Extensions directory found');
    }
    
    if (fs.existsSync('FrontEnd/modules/blueprints')) {
      detectedFeatures.push('üõí Configured Commerce - Blueprint structure found');
    }
    
    // Check for CMS indicators
    if (fs.existsSync('modules') && fs.existsSync('App_Data')) {
      detectedFeatures.push('üìù CMS - Module structure found');
    }
    
    if (fs.existsSync('Views') && fs.existsSync('Models')) {
      detectedFeatures.push('üìù CMS - MVC structure found');
    }
    
    // Check package.json for dependencies
    if (fs.existsSync('package.json')) {
      const packageData = JSON.parse(fs.readFileSync('package.json', 'utf8'));
      const allDeps = { ...packageData.dependencies, ...packageData.devDependencies };
      
      if (Object.keys(allDeps).some(dep => dep.includes('insite'))) {
        detectedFeatures.push('üõí Configured Commerce - Insite dependencies found');
      }
      
      if (Object.keys(allDeps).some(dep => dep.includes('episerver'))) {
        detectedFeatures.push('üìù CMS - Episerver dependencies found');
      }
      
      if (Object.keys(allDeps).some(dep => dep.includes('@optimizely/optimizely-sdk'))) {
        detectedFeatures.push('üß™ Experimentation - SDK dependencies found');
      }
    }
    
    // Check for .csproj files
    const csprojFiles = fs.readdirSync('.').filter(file => file.endsWith('.csproj'));
    if (csprojFiles.length > 0) {
      detectedFeatures.push('‚öôÔ∏è .NET Project - C# project files found');
    }
    
    // Check for web.config
    if (fs.existsSync('web.config') || fs.existsSync('Web.config')) {
      detectedFeatures.push('üåê ASP.NET - Web configuration found');
    }
    
    if (detectedFeatures.length > 0) {
      console.log('‚úÖ Detection Results:');
      detectedFeatures.forEach(feature => console.log(`   ${feature}`));
      console.log('\nüí° Recommendations:');
      
      if (detectedFeatures.some(f => f.includes('Configured Commerce'))) {
        console.log('   ‚Ä¢ Use Commerce-specific patterns and rules');
        console.log('   ‚Ä¢ Focus on Extensions/ and FrontEnd/ directories');
      }
      
      if (detectedFeatures.some(f => f.includes('CMS'))) {
        console.log('   ‚Ä¢ Use CMS-specific content development patterns');
        console.log('   ‚Ä¢ Focus on content blocks and templates');
      }
      
      if (detectedFeatures.some(f => f.includes('Experimentation'))) {
        console.log('   ‚Ä¢ Use Experimentation SDK patterns');
        console.log('   ‚Ä¢ Focus on A/B testing implementation');
      }
      
    } else {
      console.log('‚ùì No clear Optimizely product indicators found');
      console.log('   This might be a general project or a different Optimizely product');
    }
    
    console.log('\nüöÄ Next Steps:');
    console.log('   ‚Ä¢ Run "optivise setup" to configure your IDE');
    console.log('   ‚Ä¢ Use "optivise mcp" to start the MCP server');
    console.log('   ‚Ä¢ Try context analysis with intelligent product detection');
    
  } catch (error) {
    console.error('‚ùå Error during detection:', error.message);
  }
}

function setupIDEConfiguration() {
  const packagePath = path.join(PACKAGE_ROOT, 'package.json');
  let version = '4.0.0';
  try {
    const packageData = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
    version = packageData.version;
  } catch (error) {
    console.error('Warning: Could not read package.json version, using default');
  }

  console.log(`
üõ†Ô∏è  Optivise v${version} IDE Setup

To configure Optivise with your IDE, add the following to your MCP configuration:

For Cursor IDE (.cursor-mcp.json or cursor-mcp.json):
{
  "mcpServers": {
    "optivise": {
      "command": "optivise",
      "args": ["mcp"],
      "env": {
        "OPTIDEV_DEBUG": "false"
      }
    }
  }
}

For VS Code (settings.json):
{
  "mcp.servers": {
    "optivise": {
      "command": "optivise",
      "args": ["mcp"]
    }
  }
}

Available Tool:
‚úÖ optidev_context_analyzer - Analyzes prompts for Optimizely context and provides curated information

üéØ v${version} Features:
‚ú® Intelligent context analysis with relevance scoring (0-1)
‚ú® Automatic product detection for 11+ Optimizely products
‚ú® Curated responses with actionable steps and best practices
‚ú® Only responds to Optimizely-related queries (>0.7 relevance)
‚ú® Modern TypeScript architecture with fast response times

After configuration, restart your IDE to enable Optivise v${version}.
  `);
}

async function startMCPServer(options = {}) {
  const packagePath = path.join(PACKAGE_ROOT, 'package.json');
  let version = '4.0.0';
  try {
    const packageData = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
    version = packageData.version;
  } catch (error) {
    console.error('Warning: Could not read package.json version, using default');
  }

  console.error(`üöÄ Starting Optivise MCP Server v${version}...`);
  
  // Check for the compiled server
  const serverPath = path.join(PACKAGE_ROOT, 'dist', 'index.js');
  
  if (!fs.existsSync(serverPath)) {
    console.error('‚ùå Compiled server not found. Building...');
    
    // Try to build the project
    const buildChild = spawn('npm', ['run', 'build'], {
      stdio: 'pipe',
      cwd: PACKAGE_ROOT,
      shell: process.platform === 'win32'
    });

    buildChild.on('close', (code) => {
      if (code === 0) {
        console.error('‚úÖ Build successful. Starting server...');
        startServer(serverPath, options);
      } else {
        console.error('‚ùå Build failed. Please run "npm run build" manually.');
        process.exit(1);
      }
    });

    buildChild.on('error', (error) => {
      console.error('‚ùå Build process failed:', error.message);
      console.error('üí° Please run "npm run build" manually from the package directory.');
      process.exit(1);
    });

    return;
  }

  startServer(serverPath, options);
}

function startDevServer(options = {}) {
  console.error('üöÄ Starting Optivise in development mode...');
  
  const devServerPath = path.join(PACKAGE_ROOT, 'src', 'index.ts');
  
  if (!fs.existsSync(devServerPath)) {
    console.error('‚ùå Development server not found at:', devServerPath);
    console.error('üí° Please ensure you are in the correct directory.');
    process.exit(1);
  }

  const env = { ...process.env };
  if (options.debug) {
    env.OPTIDEV_DEBUG = 'true';
  }

  const child = spawn('npx', ['tsx', devServerPath], {
    stdio: 'inherit',
    cwd: PACKAGE_ROOT,
    env,
    shell: process.platform === 'win32'
  });

  child.on('error', (error) => {
    console.error('‚ùå Failed to start development server:', error.message);
    console.error('üí° Make sure tsx is installed: npm install -g tsx');
    process.exit(1);
  });

  child.on('exit', (code) => {
    process.exit(code || 0);
  });
}

function startServer(serverPath, options = {}) {
  const env = { ...process.env };
  if (options.debug) {
    env.OPTIDEV_DEBUG = 'true';
  }

  const child = spawn('node', [serverPath], {
    stdio: 'inherit',
    env
  });

  child.on('error', (error) => {
    console.error('‚ùå Failed to start MCP server:', error.message);
    process.exit(1);
  });

  child.on('exit', (code) => {
    process.exit(code || 0);
  });
}

async function startHTTPServer(options = {}) {
  const packagePath = path.join(PACKAGE_ROOT, 'package.json');
  let version = '4.0.0';
  try {
    const packageData = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
    version = packageData.version;
  } catch (error) {
    console.error('Warning: Could not read package.json version, using default');
  }

  console.error(`üåê Starting Optivise HTTP Server v${version}...`);
  console.error('üìù This server provides browser-based testing for the MCP context analyzer');
  
  // Check for the compiled server
  const serverPath = path.join(PACKAGE_ROOT, 'dist', 'index.js');
  
  if (!fs.existsSync(serverPath)) {
    console.error('‚ùå Compiled server not found. Building...');
    
    // Try to build the project
    const buildChild = spawn('npm', ['run', 'build'], {
      stdio: 'pipe',
      cwd: PACKAGE_ROOT,
      shell: process.platform === 'win32'
    });

    buildChild.on('close', (code) => {
      if (code === 0) {
        console.error('‚úÖ Build successful. Starting HTTP server...');
        startHTTPServerProcess(serverPath, options);
      } else {
        console.error('‚ùå Build failed. Please run "npm run build" manually.');
        process.exit(1);
      }
    });

    buildChild.on('error', (error) => {
      console.error('‚ùå Build process failed:', error.message);
      console.error('üí° Please run "npm run build" manually from the package directory.');
      process.exit(1);
    });

    return;
  }

  startHTTPServerProcess(serverPath, options);
}

function startHTTPServerProcess(serverPath, options = {}) {
  const env = { 
    ...process.env,
    OPTIVISE_MODE: 'server',
    PORT: '3000'
  };
  
  if (options.debug) {
    env.OPTIDEV_DEBUG = 'true';
  }

  const child = spawn('node', [serverPath], {
    stdio: 'inherit',
    env
  });

  child.on('error', (error) => {
    console.error('‚ùå Failed to start HTTP server:', error.message);
    process.exit(1);
  });

  child.on('exit', (code) => {
    process.exit(code || 0);
  });
}

async function testMCPConnection(options = {}) {
  console.log('üß™ Testing Optivise MCP Configuration...\n');
  
  const packagePath = path.join(PACKAGE_ROOT, 'package.json');
  let version = '4.0.0';
  try {
    const packageData = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
    version = packageData.version;
  } catch (error) {
    console.error('Warning: Could not read package.json version, using default');
  }

  // Test 1: Check if server can start
  console.log('üìã Test 1: Server Startup Test');
  const serverPath = path.join(PACKAGE_ROOT, 'dist', 'index.js');
  
  if (!fs.existsSync(serverPath)) {
    console.log('‚ùå Compiled server not found - need to build first');
    console.log('üí° Run: npm run build');
    return;
  } else {
    console.log('‚úÖ Compiled server found');
  }

  // Test 2: Quick server connectivity test
  console.log('\nüìã Test 2: MCP Server Quick Start Test');
  try {
    const testChild = spawn('node', [serverPath], {
      stdio: 'pipe',
      timeout: 5000 // 5 second timeout
    });

    let output = '';
    testChild.stdout?.on('data', (data) => {
      output += data.toString();
    });

    testChild.stderr?.on('data', (data) => {
      output += data.toString();
    });

    setTimeout(() => {
      testChild.kill('SIGTERM');
      
      if (output.includes('Optivise MCP server started successfully')) {
        console.log('‚úÖ MCP server starts successfully');
      } else if (output.includes('Starting Optivise')) {
        console.log('‚úÖ MCP server initialization working');
      } else {
        console.log('‚ö†Ô∏è  MCP server may have issues - check logs');
        if (options.debug) {
          console.log('Debug output:', output);
        }
      }
    }, 3000);

  } catch (error) {
    console.log('‚ùå MCP server test failed:', error.message);
  }

  // Test 3: Configuration validation
  console.log('\nüìã Test 3: Configuration Files');
  
  const cursorConfigs = [
    '.cursor-mcp.json',
    'cursor-mcp.json',
    '.cursor/mcp.json'
  ];
  
  let foundConfig = false;
  for (const config of cursorConfigs) {
    if (fs.existsSync(config)) {
      console.log(`‚úÖ Found MCP config: ${config}`);
      try {
        const configData = JSON.parse(fs.readFileSync(config, 'utf8'));
        if (configData.mcpServers?.optivise) {
          console.log('‚úÖ Optivise configuration found');
          foundConfig = true;
        } else {
          console.log('‚ö†Ô∏è  Optivise not configured in MCP settings');
        }
      } catch (e) {
        console.log('‚ùå Invalid JSON in config file');
      }
      break;
    }
  }
  
  if (!foundConfig) {
    console.log('‚ö†Ô∏è  No MCP configuration found');
    console.log('üí° Run: optivise setup');
  }

  // Test 4: Global installation check
  console.log('\nüìã Test 4: Global Installation Check');
  try {
    const which = process.platform === 'win32' ? 'where' : 'which';
    const checkChild = spawn(which, ['optivise'], { stdio: 'pipe' });
    
    checkChild.on('close', (code) => {
      if (code === 0) {
        console.log('‚úÖ Optivise globally accessible');
      } else {
        console.log('‚ö†Ô∏è  Optivise may not be globally installed');
        console.log('üí° Run: npm install -g optivise');
      }
    });

    checkChild.on('error', () => {
      console.log('‚ö†Ô∏è  Could not verify global installation');
    });

  } catch (error) {
    console.log('‚ö†Ô∏è  Could not check global installation');
  }

  console.log(`\nüéØ Optivise v${version} Test Summary:`);
  console.log('   ‚Ä¢ If all tests pass, your MCP server should work with IDEs');
  console.log('   ‚Ä¢ For browser testing, run: optivise server');
  console.log('   ‚Ä¢ For IDE setup, run: optivise setup');
  console.log('   ‚Ä¢ For debugging, add --debug flag to any command');
}

// Parse command line arguments
const args = process.argv.slice(2);
const options = {};

// Extract options
for (let i = args.length - 1; i >= 0; i--) {
  if (args[i] === '--debug') {
    options.debug = true;
    args.splice(i, 1);
  } else if (args[i] === '--help') {
    printUsage();
    process.exit(0);
  }
}

const command = args[0];

switch (command) {
  case 'mcp':
  case 'start':
    startMCPServer(options);
    break;
    
  case 'server':
    startHTTPServer(options);
    break;
    
  case 'dev':
    startDevServer(options);
    break;
    
  case 'test':
    testMCPConnection(options);
    break;
    
  case 'detect':
    detectOptimizelyProduct(options);
    break;
    
  case 'setup':
    setupIDEConfiguration();
    break;
    
  case 'version':
    printVersion();
    break;
    
  default:
    if (!command) {
      printUsage();
    } else {
      console.error(`‚ùå Unknown command: ${command}`);
      console.error('Run "optivise --help" for usage information.');
      process.exit(1);
    }
}